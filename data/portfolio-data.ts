export interface Project {
  name: string;
  description: string;
  longDescription: string;
  readme: string;
  technologies: string[];
  githubUrl: string;
  liveUrl: string;
  featured: boolean;
  image: string;
}

export interface Experience {
  company: string;
  role: string;
  duration: string;
  location: string;
  description: string;
  highlights: string[];
  technologies: string[];
}

export interface Education {
  institution: string;
  degree: string;
  duration: string;
  gpa: string;
}

export interface SkillCategory {
  frontend: string[];
  backend: string[];
  tools: string[];
  other: string[];
}

export interface About {
  name: string;
  title: string;
  bio: string;
  location: string;
  email: string;
  linkedin: string;
  github: string;
  twitter: string;
  resumeUrl: string;
  avatar?: string;
}

export interface PortfolioData {
  about: About;
  skills: SkillCategory;
  experience: Experience[];
  education: Education[];
  projects: Project[];
}

export const portfolioData: PortfolioData = {
  "about": {
    "name": "Jaimin",
    "title": "Full Stack Developer",
    "bio": "Passionate developer who loves building products that solve real problems. Experienced in modern web technologies and always learning something new.",
    "location": "Your City, Country",
    "email": "jaimin@example.com",
    "linkedin": "https://linkedin.com/in/jaimin",
    "github": "https://github.com/Jaiminp007",
    "twitter": "https://twitter.com/jaimin",
    "resumeUrl": "/resume.pdf",
    "avatar": "https://avatars.githubusercontent.com/u/95100522?v=4"
  },
  "skills": {
    "frontend": [
      "React",
      "Next.js",
      "TypeScript",
      "Tailwind CSS",
      "Redux",
      "Framer Motion"
    ],
    "backend": [
      "Node.js",
      "Express",
      "Python",
      "FastAPI",
      "PostgreSQL",
      "MongoDB"
    ],
    "tools": [
      "Git",
      "Docker",
      "AWS",
      "Vercel",
      "Figma"
    ],
    "other": [
      "REST APIs",
      "GraphQL",
      "CI/CD",
      "Agile",
      "MCP"
    ]
  },
  "experience": [
    {
      "company": "Tech Company",
      "role": "Software Engineer",
      "duration": "Jan 2023 - Present",
      "location": "Remote",
      "description": "Building scalable web applications...",
      "highlights": [
        "Led development of feature X that increased user engagement by 40%",
        "Implemented CI/CD pipeline reducing deployment time by 60%"
      ],
      "technologies": [
        "React",
        "Node.js",
        "AWS"
      ]
    }
  ],
  "education": [
    {
      "institution": "University Name",
      "degree": "B.Tech in Computer Science",
      "duration": "2019 - 2023",
      "gpa": "8.5/10"
    }
  ],
  "projects": [
    {
      "name": "CFM-Project",
      "description": "CFM : Meet Market Algorithm ",
      "longDescription": "CFM : Meet Market Algorithm ",
      "readme": "## About\n\nThis repository contains **Team 13‚Äôs submission** to the **CFM 101 annual team competition** at the **University of Waterloo**.  \nThe project placed **1st overall**, achieving a **3.2% portfolio return over one week** during a **3.6% benchmark return period**.\n\n\n# Market Meet ‚Äî Quantitative Portfolio Construction\n\nA benchmark-relative quantitative portfolio construction system built in Python.\n\nThis project implements a **systematic, rules-based equity portfolio pipeline** that selects, scores, and allocates stocks based on their risk characteristics relative to a blended market benchmark. The focus is on **risk control, diversification, and evaluation discipline**, rather than short-term alpha prediction.\n\nThe system was originally developed in a team setting and has since been refactored into a **configurable, standalone portfolio builder**.\n\n\n---\n\n## Key Features\n\n- Ticker validation and liquidity filtering\n- Blended benchmark construction (S&P 500 + TSX)\n- Rolling risk estimation (beta and correlation)\n- Multi-factor scoring and portfolio weighting\n- Defensive asset overlay\n- Sector, position, and currency constraints\n- Fully configurable via command-line arguments\n- Notebook-based walkthrough for explanation and visualization\n\n---\n\n## Methodology Overview\n\n### 1. Ticker Validation\nCandidate tickers are filtered based on:\n- Availability of historical price data\n- Average daily trading volume\n- Market listing (U.S. or Canadian equities)\n\nThis ensures that only liquid, tradable securities are considered.\n\n---\n\n### 2. Benchmark Construction\nA **blended benchmark** is constructed using:\n- S&P 500 (`^GSPC`)\n- TSX Composite (`^GSPTSE`)\n\nDaily benchmark returns are computed as the equal-weight average of both indices.\n\n---\n\n### 3. Risk Estimation\nFor each valid ticker, the system estimates:\n- **Rolling beta** relative to the blended benchmark\n- **Rolling correlation** with the benchmark\n- **Annualized volatility**\n- **Relative volatility penalty** compared to benchmark volatility\n\nRolling windows are used to emphasize recent behavior and reduce noise.\n\n---\n\n### 4. Scoring Model\nEach stock is scored based on its distance from an ‚Äúideal‚Äù benchmark-relative profile:\n- Beta close to 1\n- High correlation with the benchmark\n- Controlled relative volatility\n\nA composite score is computed and normalized to produce portfolio weights.\n\n---\n### 5. Portfolio Construction & Constraints\nThe raw portfolio is refined through multiple constraint layers:\n- Maximum position weight\n- Maximum sector exposure\n- Minimum and maximum number of holdings\n- Minimum position size\n- Defensive asset allocation (utilities, healthcare, consumer defensive)\n- CAD / USD exposure balancing\n- Market capitalization diversity\n\nWeights are normalized after each step to ensure full investment.\n\n---\n\n## Repository Structure\n\n```\n.\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ notebooks/\n‚îÇ   ‚îî‚îÄ‚îÄ market_meet_report.ipynb\n‚îú‚îÄ‚îÄ requirements.txt\n‚îú‚îÄ‚îÄ Tickers.csv\n‚îî‚îÄ‚îÄ README.md\n```\n\n---\n\n\n## Usage\n\nPrepare a CSV file containing one ticker per line:\n\n```\nAAPL\nMSFT\nNVDA\nTD.TO\nENB.TO\n```\n\nRun the portfolio builder:\n\n```bash\npython main.py --tickers Tickers.csv\n```\n\nExample with custom parameters:\n\n```bash\npython main.py \\\n  --tickers Tickers.csv \\\n  --portfolio-cad 250000 \\\n  --start 2025-01-01 \\\n  --end 2025-06-01 \\\n  --max-position 10 \\\n  --max-sector 30 \\\n  --max-holdings 20 \\\n  --output-name portfolio \\\n  --outdir outputs\n```\n\n---\n\n## Outputs\n\n- `portfolio_full.csv` ‚Äî full portfolio with prices, weights, and share counts\n- `orders.csv` ‚Äî simplified order list (ticker and shares)\n\n\n\n---\n\n## Summary\n\nThis project demonstrates systematic portfolio construction, risk-aware allocation, practical constraint handling, and clean separation between research and execution logic. It is intended as a foundational quantitative finance project showcasing both analytical reasoning and software engineering practices.\n",
      "technologies": [
        "Jupyter Notebook"
      ],
      "githubUrl": "https://github.com/Jaiminp007/CFM-Project",
      "liveUrl": "",
      "featured": false,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "AlgoClash-Where-Code-Collides",
      "description": "üí• An open-source platform where autonomous AI agents battle for supremacy in a simulated stock market. Watch agents trade, chat, and compete in real-time 5-minute sessions to achieve the highest ROI. Features a live leaderboard, backtesting mode, and an easy Docker setup. Build your own agent and join the fight! üèÜ",
      "longDescription": "üí• An open-source platform where autonomous AI agents battle for supremacy in a simulated stock market. Watch agents trade, chat, and compete in real-time 5-minute sessions to achieve the highest ROI. Features a live leaderboard, backtesting mode, and an easy Docker setup. Build your own agent and join the fight! üèÜ",
      "readme": "# AI Trader Battlefield\n\nAn experimental platform where AI-generated trading algorithms compete against each other in a simulated stock market. Multiple Large Language Models (LLMs) automatically generate trading strategies, which then battle in a 5-minute trading session to see which algorithm achieves the highest return on investment (ROI).\n\n---\n\n## üìê Architecture Overview\n<img width=\"1156\" height=\"501\" alt=\"Screenshot 2025-07-25 at 11 57 23 AM\" src=\"https://github.com/user-attachments/assets/b4f4d481-9d2d-4b2c-9e56-b36efd55736a\" />\n\n---\n\n> All agents start with the same capital and compete in real time as prices shift based on their combined trading behavior.\n\n---\n\n## üß† Description\n\nThis platform demonstrates the intersection of AI code generation and algorithmic trading by:\n\n1. **Using LLMs to generate trading algorithms** - Select from 50+ AI models (Claude, Gemini, GPT, Llama, etc.) to automatically generate Python trading functions\n2. **Simulating realistic market conditions** - A custom order book and tick-based engine processes trades with price-time priority matching\n3. **Competing strategies head-to-head** - 2-6 AI-generated algorithms compete simultaneously on the same stock data\n4. **Visualizing performance in real-time** - Interactive dashboard shows live leaderboards, portfolio values, and market charts\n\nEach generated algorithm receives tick-by-tick market data and makes autonomous BUY/SELL/HOLD decisions. The simulation engine processes these orders through a realistic order-matching system, and the agent with the highest ROI at session end wins.\n\n---\n\n## üåü Core Features\n\n### ü§ñ AI-Powered Algorithm Generation\n- **50+ LLM Integration** - Generate strategies using Claude Opus, Gemini, GPT-4, Llama, DeepSeek, Mistral, and more via OpenRouter API\n- **Automatic Code Creation** - LLMs write complete Python trading functions based on strategy prompts\n- **Algorithm Preview** - Review and inspect generated code before running simulations\n- **Multi-Model Comparison** - Test which AI model creates the most profitable strategies\n\n### üèõ Advanced Market Simulation\n- **Order Book Engine** - Professional-grade order matching with price-time priority\n- **Realistic Tick Data** - Historical data for AAPL, GOOGL, TSLA, MSFT, AMZN, NVDA, META, NFLX\n- **60-Tick Sessions** - Each battle runs for 60 market ticks (~5 minutes real-time)\n- **Multiple Agent Support** - Run 2-6 competing algorithms simultaneously\n\n### üìà Interactive Dashboard\n- **Live Leaderboard** - Real-time ROI rankings updated every tick\n- **Market Charts** - Dynamic price visualization with Recharts\n- **Performance Metrics** - Track P&L, win rate, max drawdown, and portfolio value\n- **Trade History** - Complete audit log of all executed orders\n\n---\n\n## üèÜ Scoring System\n\nEach trading session lasts **60 ticks** (approximately 5 minutes). Agents are ranked by:\n\n| Metric              | Description                                  |\n|---------------------|----------------------------------------------|\n| **ROI (%)**         | Return on investment - primary ranking metric |\n| **P&L**             | Absolute profit or loss in dollars           |\n| **Win Rate (%)**    | Percentage of profitable trades              |\n| **Max Drawdown (%)** | Largest drop from peak portfolio value      |\n| **Portfolio Value** | Total cash + stock holdings at market price  |\n| **Trade Count**     | Total number of executed trades              |\n\n> The agent with the **highest ROI** wins the session.\n\n---\n\n## üõ†Ô∏è Tech Stack\n\n### Backend\n| Component | Technology | Purpose |\n|-----------|-----------|---------|\n| **Web Framework** | Flask | REST API server |\n| **Language** | Python 3.11+ | Core simulation logic |\n| **LLM Integration** | OpenRouter API | Access to 50+ AI models |\n| **Market Data** | Yahoo Finance (yfinance) | Historical stock data |\n| **Data Processing** | Pandas, NumPy | Data analysis |\n| **Server** | Gunicorn | Production WSGI server |\n\n### Frontend\n| Component | Technology | Purpose |\n|-----------|-----------|---------|\n| **Framework** | React 18.2 | User interface |\n| **Routing** | React Router v7 | Page navigation |\n| **Styling** | Tailwind CSS | Responsive design |\n| **Charts** | Recharts 3.3 | Market visualization |\n| **Animation** | Framer Motion 12 | Smooth transitions |\n\n### Deployment\n- **Frontend Hosting** - Vercel\n- **Backend Server** - Flask with Gunicorn\n- **No Database** - In-memory simulation state\n\n---\n\n## üöÄ Live Demo\n\nThe platform is live at: **[ai-trader-battlefield-fro.onrender.com](https://ai-trader-battlefield-fro.onrender.com)**\n\n<img width=\"1509\" height=\"762\" alt=\"Screenshot 2025-12-09 at 2 27 58‚ÄØPM\" src=\"https://github.com/user-attachments/assets/9221c62d-322e-40ac-a76f-78d817442ba9\" />\n\n---\n\n## ‚öôÔ∏è How It Works\n\n### 1. Algorithm Generation\n```\nUser selects AI models ‚Üí OpenRouter API generates trading functions ‚Üí Code saved as Python files\n```\n\nEach generated algorithm implements:\n```python\ndef execute_trade(ticker: str, cash_balance: float, shares_held: int) -> str:\n    # AI-generated trading logic\n    return \"BUY\" | \"SELL\" | \"HOLD\"\n```\n\n### 2. Simulation Engine\n```\nLoad tick data ‚Üí For each tick:\n  - Call each agent's execute_trade()\n  - Collect orders (BUY/SELL/HOLD)\n  - Match orders in order book\n  - Update prices based on trades\n  - Calculate portfolio values\n‚Üí Return final rankings\n```\n\n### 3. Order Matching\n- **Price-time priority** - Best price gets filled first; ties broken by timestamp\n- **Partial fills supported** - Large orders can be partially executed\n- **Bid-ask spread** - Realistic market microstructure\n- **No short selling** - Long-only strategies\n\n---\n\n## üì° API Endpoints\n\n| Endpoint | Method | Description |\n|----------|--------|-------------|\n| `/api/ai_agents` | GET | List available AI models |\n| `/api/data_files` | GET | List available stock datasets |\n| `/api/algos` | GET | List generated algorithms |\n| `/api/algos/{filename}` | GET | Preview algorithm code |\n| `/api/generate` | POST | Generate new algorithms |\n| `/api/run` | POST | Start simulation |\n| `/api/status/{sim_id}` | GET | Get simulation status |\n\n---\n\n## üìÅ Project Structure\n\n```\nalgoclash-v1-test/\n‚îú‚îÄ‚îÄ backend/\n‚îÇ   ‚îú‚îÄ‚îÄ app.py                    # Flask server & REST API\n‚îÇ   ‚îú‚îÄ‚îÄ market/                   # Simulation engine\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ market_simulation.py  # Session orchestrator\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order_book.py         # Order matching engine\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tick_generator.py     # Stock data provider\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agent.py              # Trading agent manager\n‚îÇ   ‚îú‚îÄ‚îÄ open_router/              # LLM integration\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ algo_gen.py           # Algorithm generator\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model_fecthing.py     # Fetch AI models\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ai_agents.json        # 50+ model configs\n‚îÇ   ‚îú‚îÄ‚îÄ data/                     # Historical stock CSVs\n‚îÇ   ‚îî‚îÄ‚îÄ generate_algo/            # Generated Python algorithms\n‚îú‚îÄ‚îÄ frontend/\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/           # 16 React components\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.js      # Main battle arena\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ResultsDashboard.js  # Leaderboard\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models.js         # AI model directory\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.js\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îî‚îÄ‚îÄ README.md\n```\n\n---\n\n## üéØ Use Cases\n\n### What This IS\n- Educational platform for algorithmic trading concepts\n- AI code generation benchmark (which LLM writes better trading code?)\n- Strategy testing environment with realistic market simulation\n- Interactive demonstration of market dynamics\n\n### What This IS NOT\n- Production trading system (no real money or live markets)\n- Financial advice or investment tool\n- High-frequency trading platform\n- Connection to real brokerages\n\n---\n\n## ‚ö° Configuration\n\n### Simulation Parameters\n```python\nSimulationConfig(\n    max_ticks=60,              # Session length (60 ticks)\n    tick_sleep=1.0,            # Seconds between ticks\n    initial_cash=10000.0,      # Starting capital per agent\n    enable_order_book=True,    # Realistic order matching\n    allow_short=False,         # No short selling\n    allow_negative_cash=False  # No margin trading\n)\n```\n\n### Supported Stocks\n- AAPL (Apple)\n- GOOGL (Google)\n- TSLA (Tesla)\n- MSFT (Microsoft)\n- AMZN (Amazon)\n- NVDA (NVIDIA)\n- META (Meta)\n- NFLX (Netflix)\n\n---\n\n## ü§ù Contributing\n\nContributions are welcome! This is an experimental platform under active development.\n\n**Current Branch:** `v1`\n**Main Branch:** `main`\n\n---\n\n## üìÑ License\n\nSee [LICENSE](LICENSE) file for details.\n\n---\n\n## üôè Acknowledgments\n\n- **OpenRouter** - For providing unified access to 50+ LLM providers\n- **Yahoo Finance** - For historical market data\n- All open-source libraries that made this project possible\n\n---\n\n**Built with Flask, React, and AI curiosity.**\n\n\n",
      "technologies": [
        "Python"
      ],
      "githubUrl": "https://github.com/Jaiminp007/AlgoClash-Where-Code-Collides",
      "liveUrl": "https://ai-trader-battlefield-fro.onrender.com",
      "featured": true,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "QuantFlow",
      "description": "A high-performance C++17 statistical arbitrage backtesting engine for pairs trading strategies. Processes tick-level market data using Z-score mean reversion signals to identify and execute profitable trading opportunities with sub-microsecond latency.",
      "longDescription": "A high-performance C++17 statistical arbitrage backtesting engine for pairs trading strategies. Processes tick-level market data using Z-score mean reversion signals to identify and execute profitable trading opportunities with sub-microsecond latency.",
      "readme": "# QuantFlow\n\nA high-performance C++17 statistical arbitrage backtesting engine for pairs trading strategies. Processes tick-level market data using Z-score mean reversion signals to identify and execute profitable trading opportunities with sub-microsecond latency.\n\n## Features\n\n- **High Performance**: Optimized for speed with `-O3` compilation, minimal heap allocations\n- **Event-Driven Architecture**: Processes tick data in real-time simulation\n- **Statistical Arbitrage**: Z-score based mean-reverting spread strategy\n- **Zero Dependencies**: Uses only C++17 Standard Library\n- **Comprehensive Analytics**: Sharpe ratio, max drawdown, and PnL tracking\n\n## Technical Specifications\n\n- **Language**: C++17\n- **Compiler**: g++ or clang++\n- **Build Flags**: `-std=c++17 -Wall -Wextra -Wpedantic -O3`\n- **Performance**: Capable of processing millions of ticks per second\n\n## System Architecture\n\nThe system follows a high-frequency event loop architecture optimized for low-latency simulation:\n\n![QuantFlow Architecture](architecture.png)\n\n1.  **Data Creation & Storage**: Synthetic tick data is generated or loaded from CSV.\n2.  **Initialization**: Vectors are pre-allocated and strategy parameters are configured.\n3.  **The Event Loop**: The engine iterates through time-series data tick-by-tick.\n4.  **Execution**: Signals are generated (Z-score), and portfolio orders are executed immediately based on logic.\n5.  **The Result**: Performance metrics (Sharpe, PnL) are calculated upon loop completion.\n\n## Project Structure\n\n```\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ TickData.h              # Tick data structure\n‚îÇ   ‚îú‚îÄ‚îÄ DataReader.h/cpp        # CSV data reader\n‚îÇ   ‚îú‚îÄ‚îÄ SignalGenerator.h/cpp   # Z-score trading signals\n‚îÇ   ‚îú‚îÄ‚îÄ PortfolioManager.h/cpp  # Position and PnL management\n‚îÇ   ‚îú‚îÄ‚îÄ PerformanceCalculator.h/cpp # Analytics and reporting\n‚îÇ   ‚îî‚îÄ‚îÄ main.cpp                # Main backtester application\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îî‚îÄ‚îÄ tick_data.csv           # Market tick data (generated)\n‚îú‚îÄ‚îÄ Makefile                    # Build system\n‚îî‚îÄ‚îÄ generate_data.cpp           # Synthetic data generator\n```\n\n## Building\n\n```bash\n# Build the backtester\nmake\n\n# Clean build artifacts\nmake clean\n```\n\n## Usage\n\n### 0. Fetch Real Market Data (optional)\n\n```bash\npython fetch_real_data.py\n```\n\nConfigure `fetch_real_data.py` with your Twelve Data `API_KEY`, desired `SYMBOL_1`/`SYMBOL_2` (e.g., `KO` and `PEP`), `INTERVAL`, and `OUTPUT_SIZE`. The script maps the assets to `SYM_A`/`SYM_B`, sorts ticks chronologically, and writes a backtester-ready CSV to `data/tick_data.csv`.\n\n### 1. Generate Test Data\n\n```bash\n# Compile and run data generator\ng++ -std=c++17 -O3 generate_data.cpp -o generate_data\n./generate_data\n```\n\nThis creates `data/tick_data.csv` with 200,000 ticks of synthetic mean-reverting price data.\n\n### 2. Run Backtester\n\n```bash\n./backtester\n```\n\n### 3. Configure Strategy Parameters\n\nEdit `src/main.cpp` to adjust:\n\n```cpp\nconst int lookback = 200;       // Z-score lookback window\nconst double entry_z = 1.0;     // Entry threshold (std devs)\nconst double exit_z = 0.2;      // Exit threshold (std devs)\nconst double initial_cash = 100000.0;  // Starting capital\n```\n\n**Parameter Guidelines:**\n- **Conservative**: `lookback=1000, entry_z=2.0, exit_z=0.5`\n- **Moderate**: `lookback=500, entry_z=1.5, exit_z=0.3`\n- **Aggressive**: `lookback=200, entry_z=1.0, exit_z=0.2`\n- **High-Frequency**: `lookback=50, entry_z=0.5, exit_z=0.1`\n\n## Input Data Format\n\nCSV file with columns: `timestamp,symbol,price,volume`\n\n```csv\n1665158400000000001,SYM_A,100.01,50\n1665158400000000002,SYM_B,120.51,30\n```\n\n- **Timestamp**: Nanoseconds since epoch (uint64_t)\n- **Symbol**: String (e.g., \"SYM_A\", \"SYM_B\")\n- **Price**: Double\n- **Volume**: uint64_t\n\n## Example Output\n\n```\n========== Trade Statistics ==========\nTotal Trades:     56\nLong Entries:     15\nShort Entries:    13\nPosition Closes:  28\n======================================\n\n========== Performance Report ==========\nInitial Capital:  $100000.00\nFinal Capital:    $293653.01\nTotal Return:     193.65%\nSharpe Ratio:     0.7711\nMax Drawdown:     0.20%\n========================================\n\nBacktest finished.\n```\n\nResults above were generated using Coke (`KO`) vs Pepsi (`PEP`) tick data retrieved through `fetch_real_data.py`.\n\n## Strategy Logic\n\n1. **Signal Generation**: Calculates Z-score of price spread between two symbols\n2. **Entry Rules**:\n   - Z-score > `entry_z` ‚Üí GO_SHORT (sell A, buy B)\n   - Z-score < `-entry_z` ‚Üí GO_LONG (buy A, sell B)\n3. **Exit Rules**:\n   - |Z-score| < `exit_z` ‚Üí GO_FLAT (close position)\n\n## Performance Optimization\n\n- Pre-allocated vectors to avoid heap allocations\n- Efficient CSV parsing with minimal string operations\n- O(1) price lookups using `std::map`\n- Compiled with `-O3` optimization flag\n\n## License\n\nMIT License - See LICENSE file for details\n\n## Author\n\nJaimin Patel\n",
      "technologies": [
        "C++"
      ],
      "githubUrl": "https://github.com/Jaiminp007/QuantFlow",
      "liveUrl": "",
      "featured": true,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "EDITH-Even-Dead-Im-Alive-",
      "description": "It is a AI bot called EDITH.It is pulged into ChatGPT-4 on backend so It will give responses on base of ChatGPT",
      "longDescription": "It is a AI bot called EDITH.It is pulged into ChatGPT-4 on backend so It will give responses on base of ChatGPT",
      "readme": "# E.D.I.T.H. (Even Dead, I'm The Hero)\n\n## Description\n\n**E.D.I.T.H.** is a chatbot designed to be an AI-powered assistant. The goal is to create an interactive and engaging user experience where the chatbot can answer questions, provide information, and even share fun facts or jokes. This project is inspired by the AI of the same name from the Marvel Cinematic Universe.\n\n***Note:*** The main functionality of the chatbot is currently not operational due to a missing API key for the OpenAI service. However, a demo version with pre-set questions and answers is available.\n\n## Features\n\n- **Interactive Chat Interface:** A user-friendly chat interface for seamless interaction.\n- **AI-Powered Responses:** The chatbot is designed to connect to the OpenAI API to provide intelligent and context-aware answers.\n- **Demo Mode:** A demonstration mode is available to showcase the chatbot's intended functionality with a set of predefined questions and answers.\n\n## Demo\n\nTo try the demo version of the chatbot, open the **`demo.html`** file in your web browser. You will be presented with a dropdown menu of pre-set questions. Select a question and click the send button to see the chatbot's response.\n\n![E.D.I.T.H. Background](jaiminp007/edith-even-dead-im-alive-/EDITH-Even-Dead-Im-Alive--e46def7336234f01c396e1dff1bac2d8efbb373f/Images/Background1.jpg)\n\n## Technologies Used\n\n- **HTML:** For the structure and layout of the web pages.\n- **CSS:** For styling the user interface and chat components.\n- **JavaScript:** For the chatbot's logic, handling user input, and interacting with the chat interface.\n\n## File Descriptions\n\n- **`index.html`:** The main landing page for the chatbot application.\n- **`demo.html`:** The page for the demonstration version of the chatbot.\n- **`style.css`:** The stylesheet that defines the visual appearance of the chatbot.\n- **`script.js`:** The JavaScript file that contains the logic for the main chatbot, including the connection to the OpenAI API.\n- **`demo.js`:** The JavaScript file that controls the functionality of the demo version of the chatbot.\n- **`Images/`:** A directory containing the images used in the application, including background images and icons.\n",
      "technologies": [
        "JavaScript"
      ],
      "githubUrl": "https://github.com/Jaiminp007/EDITH-Even-Dead-Im-Alive-",
      "liveUrl": "https://jaiminp007.github.io/EDITH-Even-Dead-Im-Alive-/",
      "featured": true,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "Advanced-Portfolio-Optimizer",
      "description": "üìä A full-stack web application for advanced portfolio optimization using Modern Portfolio Theory (MPT). Powered by a Python Flask backend (SciPy, Pandas) and an interactive frontend (Plotly.js), it allows users to visualize the Efficient Frontier, run Monte Carlo simulations, and compare multiple optimization strategies to build better investment ",
      "longDescription": "üìä A full-stack web application for advanced portfolio optimization using Modern Portfolio Theory (MPT). Powered by a Python Flask backend (SciPy, Pandas) and an interactive frontend (Plotly.js), it allows users to visualize the Efficient Frontier, run Monte Carlo simulations, and compare multiple optimization strategies to build better investment ",
      "readme": "# Advanced Modern Portfolio Theory Optimizer\n\nA sophisticated full-stack web application for portfolio optimization using Modern Portfolio Theory (MPT) with Python Flask backend and interactive frontend.\n\n## üöÄ Features\n\n### Advanced Portfolio Optimization\n- **Multiple Optimization Strategies:**\n  - Maximum Sharpe Ratio optimization using SciPy\n  - Minimum Volatility optimization\n  - Monte Carlo simulation with 10,000+ portfolios\n  \n### Interactive Visualizations\n- **Efficient Frontier Chart** - Visualize the risk-return tradeoff\n- **Monte Carlo Scatter Plot** - See all simulated portfolios\n- **Correlation Heatmap** - Understand asset relationships\n- **Portfolio Weight Charts** - Pie and bar charts for allocation\n\n### Advanced Analytics\n- **Risk Metrics Dashboard** - VaR, Diversification Score, Max Position\n- **Portfolio Comparison** - Compare multiple strategies side-by-side\n- **Optimization History** - SQLite database tracking all optimizations\n- **Real-time Calculations** - Powered by NumPy, Pandas, and SciPy\n\n## üì¶ Tech Stack\n\n### Backend\n- **Flask** - Web framework\n- **NumPy** - Numerical computations\n- **Pandas** - Data manipulation\n- **SciPy** - Optimization algorithms\n- **SQLite** - Database for history tracking\n\n### Frontend\n- **Tailwind CSS** - Modern styling\n- **Plotly.js** - Interactive charts\n- **Chart.js** - Additional visualizations\n- **Lucide Icons** - Beautiful icons\n\n## üõ†Ô∏è Installation\n\n1. **Clone the repository**\n```bash\ncd /Users/jaiminpatel/github/stock\n```\n\n2. **Create a virtual environment**\n```bash\npython3 -m venv venv\nsource venv/bin/activate  # On macOS/Linux\n```\n\n3. **Install dependencies**\n```bash\npip install -r requirements.txt\n```\n\n## üéØ Usage\n\n1. **Start the Flask server**\n```bash\npython app.py\n```\n\nThe server will start at `http://localhost:5000`\n\n2. **Open your browser**\nNavigate to `http://localhost:5000`\n\n3. **Optimize your portfolio**\n   - Enter stock tickers (comma-separated): `AAPL, MSFT, GOOG, AMZN, TSLA`\n   - Choose optimization strategy\n   - Click \"Optimize Portfolio\"\n   - View results, charts, and analytics\n\n## üìä Available Stock Tickers\n\nHistorical prices are fetched on-demand from Yahoo Finance via [`yfinance`](https://pypi.org/project/yfinance/). The dashboard suggests a curated starter list, but you can request any symbols supported by Yahoo Finance:\n- **AAPL** - Apple Inc.\n- **MSFT** - Microsoft Corporation\n- **GOOGL** - Alphabet Inc.\n- **AMZN** - Amazon.com Inc.\n- **TSLA** - Tesla Inc.\n- **NVDA** - NVIDIA Corporation\n- **JPM** - JPMorgan Chase & Co.\n- **V** - Visa Inc.\n- **META** - Meta Platforms Inc.\n- **NFLX** - Netflix Inc.\n\n> üí° Tip: mix in ETFs (e.g., `SPY`, `QQQ`) or sector funds to explore diversified allocations.\n\n## üîß API Endpoints\n\n### Portfolio Optimization\n```\nPOST /api/optimize\nBody: {\n  \"tickers\": [\"AAPL\", \"MSFT\", \"GOOG\"],\n  \"strategy\": \"max_sharpe\",\n  \"risk_free_rate\": 0.02,\n  \"num_simulations\": 10000\n}\n```\n\n### Efficient Frontier\n```\nPOST /api/efficient-frontier\nBody: {\n  \"tickers\": [\"AAPL\", \"MSFT\", \"GOOG\"],\n  \"risk_free_rate\": 0.02,\n  \"num_points\": 50\n}\n```\n\n### Correlation Matrix\n```\nPOST /api/correlation\nBody: {\n  \"tickers\": [\"AAPL\", \"MSFT\", \"GOOG\"]\n}\n```\n\n### Portfolio Statistics\n```\nPOST /api/portfolio-stats\nBody: {\n  \"tickers\": [\"AAPL\", \"MSFT\", \"GOOG\"],\n  \"weights\": [0.33, 0.33, 0.34],\n  \"risk_free_rate\": 0.02\n}\n```\n\n### Optimization History\n```\nGET /api/history\n```\n\n### Available Tickers\n```\nGET /api/tickers\n```\n\n## üìà How It Works\n\n### 1. Data Processing\n- Downloads up to five years of adjusted closing prices via yfinance (configurable per request)\n- Calculates logarithmic daily returns\n- Computes annualized mean returns and covariance matrix\n\n### 2. Monte Carlo Simulation\n- Generates 10,000+ random portfolio weight combinations\n- Calculates return, volatility, and Sharpe ratio for each\n- Identifies the optimal portfolio\n\n### 3. Optimization Algorithms\n- **Max Sharpe:** Uses SciPy's SLSQP optimizer to maximize Sharpe ratio\n- **Min Volatility:** Minimizes portfolio standard deviation\n- **Monte Carlo:** Selects best portfolio from simulation\n\n### 4. Efficient Frontier\n- Generates optimal portfolios for various target returns\n- Visualizes the risk-return tradeoff curve\n\n## üé® Features Breakdown\n\n### Main Dashboard\n- Input section with validation\n- Multiple optimization strategies\n- Adjustable risk-free rate and simulation count\n- Real-time error handling and notifications\n\n### Results Display\n- Key metrics cards (Return, Volatility, Sharpe Ratio)\n- Optimal weight allocation with visual bars\n- Interactive efficient frontier chart\n- Pie chart for weight distribution\n\n### Advanced Tabs\n1. **Optimizer** - Main optimization interface\n2. **Portfolio Comparison** - Compare strategies\n3. **Risk Analytics** - Detailed risk metrics\n4. **Correlation Matrix** - Asset correlation heatmap\n\n### Error Handling\n- Comprehensive try-catch blocks throughout\n- Validation for all user inputs\n- Null reference checks on all data\n- Informative error messages\n- Connection status monitoring\n\n## üîê Database Schema\n\n```sql\nCREATE TABLE optimizations (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  timestamp TEXT,\n  tickers TEXT,\n  strategy TEXT,\n  optimal_weights TEXT,\n  expected_return REAL,\n  volatility REAL,\n  sharpe_ratio REAL,\n  risk_free_rate REAL\n)\n```\n\n## üêõ Troubleshooting\n\n### \"Cannot connect to server\" error\n- Make sure Flask is running: `python app.py`\n- Check if port 5000 is available\n- Verify firewall settings\n\n### \"Cannot read properties of null\" error\n**FIXED!** The application now includes:\n- Comprehensive null checks on all data\n- Validation before accessing properties\n- Proper error boundaries\n- Fallback values for missing data\n\n### Import errors\n```bash\npip install --upgrade -r requirements.txt\n```\n\n## üìù License\n\nThis project is for educational purposes and demonstrates Modern Portfolio Theory concepts.\n\n## ü§ù Contributing\n\nFeel free to submit issues and enhancement requests!\n\n## üìö Learn More\n\n- [Modern Portfolio Theory](https://en.wikipedia.org/wiki/Modern_portfolio_theory)\n- [Sharpe Ratio](https://en.wikipedia.org/wiki/Sharpe_ratio)\n- [Efficient Frontier](https://en.wikipedia.org/wiki/Efficient_frontier)\n- [Monte Carlo Simulation](https://en.wikipedia.org/wiki/Monte_Carlo_method)\n\n---\n\nBuilt with ‚ù§Ô∏è using Flask, NumPy, Pandas, SciPy, and Modern Web Technologies\n",
      "technologies": [
        "HTML"
      ],
      "githubUrl": "https://github.com/Jaiminp007/Advanced-Portfolio-Optimizer",
      "liveUrl": "https://advanced-portfolio-optimizer.onrender.com/",
      "featured": false,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "High-Performance-Limit-Order-Book",
      "description": "üöÄ A high-performance C++17 limit order book and matching engine with an interactive trading terminal. This professional-grade system features real-time execution reporting, millions of orders per second throughput, and zero external dependencies. Perfect for learning financial systems, portfolio projects, or technical interview preparation.",
      "longDescription": "üöÄ A high-performance C++17 limit order book and matching engine with an interactive trading terminal. This professional-grade system features real-time execution reporting, millions of orders per second throughput, and zero external dependencies. Perfect for learning financial systems, portfolio projects, or technical interview preparation.",
      "readme": "# Quantum Trading Systems - Order Book Engine\n\nA high-performance limit order book with an interactive trading terminal built in C++17. Features professional-grade matching engine and real-time execution reporting.\n\n---\n\n## üöÄ Quick Start\n\n### Run the Trading Terminal\n```bash\n./start_trading.sh\n```\n\nOr launch the professional showcase:\n```bash\n./showcase.sh\n```\n\n### Build from Source\n```bash\nmake              # Build everything\nmake terminal     # Build just the terminal\n```\n\n---\n\n## üì¶ What's Included\n\n### Interactive Programs\n\n| Program | Description |\n|---------|-------------|\n| **trading_terminal** | Interactive trading interface with real-time reporting |\n| **orderbook** | Automated test suite with 9 validation scenarios |\n| **showcase.sh** | Professional demo launcher with menu |\n| **start_trading.sh** | Quick terminal launcher |\n\n### Core Components\n\n- **OrderBook Engine** - High-performance matching engine with Price-Time Priority\n- **Trading Terminal** - Professional UI for interactive order management\n- **Test Suite** - Comprehensive validation of all functionality\n\n---\n\n## üíª Trading Terminal Features\n\n### Interactive Menu\n\n```\n=== ACTIONS ===\n1) Market Buy     2) Market Sell\n3) Limit Buy      4) Limit Sell\n5) Cancel Order   6) View Book\n7) Run Demo       8) Clear Screen\n9) Statistics     0) Exit\n```\n\n### Real-Time Execution Reports\n\n```\n+++ EXECUTION REPORT +++\nTime        Trade ID  Order ID    Price     Qty       \n------------------------------------------------------\n12:34:56.789  1       1003        10050     100       \n12:34:56.790  2       1004        10060     20        \n```\n\n### Live Order Book Display\n\n```\n========== ORDER BOOK ==========\n\n--- ASKS (SELL ORDERS) ---\n  Price: 10070 | Qty: 200 | Orders: 1\n  Price: 10060 | Qty: 150 | Orders: 1\n  Price: 10050 | Qty: 100 | Orders: 1\n\n--- SPREAD ---\n  Best Ask: 10050 | Best Bid: 9950 | Spread: 100\n\n--- BIDS (BUY ORDERS) ---\n  Price: 9950 | Qty: 100 | Orders: 1\n  Price: 9940 | Qty: 150 | Orders: 1\n  Price: 9930 | Qty: 200 | Orders: 1\n```\n\n### Session Statistics\n\nTrack your trading activity:\n- Total orders placed\n- Number of trades executed\n- Total volume traded\n- Timestamp tracking\n\n---\n\n## üéØ Usage Examples\n\n### Example 1: Run Demo Mode\n```bash\n./trading_terminal\nChoice: 7\n```\nThis runs an automated simulation showing the matching engine in action.\n\n### Example 2: Place Limit Order\n```bash\nChoice: 3\nPrice: 10000\nQuantity: 100\n[12:34:56.789] Limit order posted (ID: 1000)\n```\n\n### Example 3: Execute Market Order\n```bash\nChoice: 1\nQuantity: 50\nMax Price: 10100\n\n+++ EXECUTION REPORT +++\nTime        Trade ID  Order ID    Price     Qty       \n------------------------------------------------------\n12:34:56.789  1       1000        10000     50        \n```\n\n### Example 4: Cancel Order\n```bash\nChoice: 5\nOrder ID to cancel: 1000\n[12:34:56.789] Cancel request sent for order 1000\n```\n\n---\n\n## ‚ö° Performance\n\n### Time Complexity\n\n| Operation | Complexity | Details |\n|-----------|-----------|---------|\n| Add Order | O(log n + m) | n = price levels, m = matches |\n| Cancel Order | O(1) average | Hash lookup + list erase |\n| Match Order | O(m) | m = number of orders matched |\n\n### Throughput\n\n- **10M** orders/sec (no matching)\n- **2-5M** orders/sec (with matching)\n- **15M** cancellations/sec\n\n### Memory\n\n- ~104 bytes per active order\n- No pre-allocation\n- Scales linearly\n\n---\n\n## üèóÔ∏è Architecture\n\n### Data Structures\n\n**Price Levels:** `std::map` - Maintains sorted order automatically\n- Bids sorted descending (highest first)\n- Asks sorted ascending (lowest first)\n\n**Orders at Each Level:** `std::list` - FIFO queue\n- O(1) removal from any position\n- Iterator stability for lookups\n\n**Order Lookup:** `std::unordered_map` - Fast cancellation\n- O(1) average lookup time\n- Stores iterator for direct access\n\n### Matching Engine\n\nImplements **Price-Time Priority**:\n1. Orders match first by price\n2. At the same price, FIFO order (first in, first out)\n3. Partial fills supported\n4. Resting orders for unfilled quantity\n\n---\n\n## üìö Documentation\n\n- **TRADING_GUIDE.md** - User manual for the terminal\n- **TERMINAL_PACKAGE.md** - Complete package overview\n- **DESIGN.md** - Technical architecture and algorithms\n- **QUICKSTART.md** - Quick reference guide\n- **INDEX.md** - Project navigation\n\n---\n\n## üîß Build System\n\n### Available Targets\n\n```bash\nmake                # Build all components\nmake terminal       # Build just the trading terminal\nmake orderbook      # Build just the test suite\nmake run            # Build and run test suite\nmake run-terminal   # Build and run trading terminal\nmake clean          # Remove all binaries\nmake rebuild        # Clean and rebuild everything\nmake debug          # Build with debug symbols\nmake performance    # Build with max optimization\n```\n\n### Requirements\n\n- C++17 compatible compiler (g++, clang++)\n- Standard library only (no external dependencies)\n- Unix-like environment (Linux, macOS)\n\n---\n\n## üìÅ Project Structure\n\n```\nc++ project/\n‚îú‚îÄ‚îÄ TradingTerminal.cpp    # Interactive trading UI\n‚îú‚îÄ‚îÄ OrderBook.h            # API definitions\n‚îú‚îÄ‚îÄ OrderBook.cpp          # Matching engine implementation\n‚îú‚îÄ‚îÄ main.cpp               # Automated test suite\n‚îú‚îÄ‚îÄ Makefile               # Build system\n‚îú‚îÄ‚îÄ start_trading.sh       # Terminal launcher\n‚îú‚îÄ‚îÄ showcase.sh            # Demo launcher\n‚îú‚îÄ‚îÄ verify.sh              # Verification script\n‚îî‚îÄ‚îÄ Documentation/\n    ‚îú‚îÄ‚îÄ TRADING_GUIDE.md\n    ‚îú‚îÄ‚îÄ TERMINAL_PACKAGE.md\n    ‚îú‚îÄ‚îÄ DESIGN.md\n    ‚îî‚îÄ‚îÄ QUICKSTART.md\n```\n\n---\n\n## üéì Key Features\n\n### Matching Engine\n\n‚úÖ **Price-Time Priority** - Fair matching based on price then time  \n‚úÖ **Immediate Matching** - Aggressive orders match instantly  \n‚úÖ **Partial Fills** - Orders can be partially executed  \n‚úÖ **Multi-Level Matching** - Orders can consume multiple price levels  \n‚úÖ **Automatic Cleanup** - Empty price levels removed automatically  \n\n### Trading Terminal\n\n‚úÖ **Real-Time Reporting** - Microsecond precision timestamps  \n‚úÖ **Session Tracking** - Monitor orders, trades, and volume  \n‚úÖ **Multiple Order Types** - Market and limit orders supported  \n‚úÖ **Order Management** - Cancel orders by ID  \n‚úÖ **Demo Mode** - Automated simulation included  \n‚úÖ **Professional UI** - Clean, intuitive interface  \n\n### Code Quality\n\n‚úÖ **Zero Warnings** - Compiles cleanly with -Wall -Wextra -pedantic  \n‚úÖ **Modern C++** - Uses C++17 features and best practices  \n‚úÖ **No Dependencies** - Standard library only  \n‚úÖ **Well Documented** - Comprehensive inline and external docs  \n‚úÖ **Production Ready** - Clean, maintainable, extensible  \n\n---\n\n## üéØ Use Cases\n\n### Educational\n- Learn how limit order books work\n- Study matching engine algorithms\n- Practice with C++17 features\n- Understand financial systems\n\n### Professional\n- Portfolio projects\n- Technical interviews\n- Trading system prototypes\n- Algorithm research\n\n### Development\n- Test trading strategies\n- Benchmark performance\n- Prototype new features\n- Market simulation\n\n---\n\n## üîç Testing\n\n### Run Automated Tests\n```bash\n./orderbook\n```\n\nThis runs 9 comprehensive test scenarios:\n1. Initial book building\n2. Aggressive sell order (multi-level match)\n3. Aggressive buy order (partial fill)\n4. Adding resting orders\n5. Order cancellation\n6. Market sweep\n7. Invalid cancellation handling\n8. Immediate complete matching\n9. Performance summary\n\n### Verify Installation\n```bash\n./verify.sh\n```\n\nRuns compilation tests and validates all functionality.\n\n---\n\n## üöÄ Getting Started Guide\n\n### Step 1: Build Everything\n```bash\nmake\n```\n\n### Step 2: Run the Demo\n```bash\n./showcase.sh\n```\nSelect option 1 to launch the trading terminal.\n\n### Step 3: Try Demo Mode\nOnce in the terminal:\n```\nChoice: 7\n```\nThis runs an automated simulation.\n\n### Step 4: Try Manual Trading\n```\nChoice: 3          # Limit Buy\nPrice: 10000\nQuantity: 100\n\nChoice: 4          # Limit Sell\nPrice: 10100\nQuantity: 50\n\nChoice: 6          # View Book\n```\n\n### Step 5: Read the Docs\n```bash\ncat TRADING_GUIDE.md\n```\n\n---\n\n## üí° Tips\n\n- **Start with demo mode** (option 7) to understand how it works\n- **View the book often** (option 6) to see current state\n- **Note order IDs** when placing orders for cancellation\n- **Use statistics** (option 9) to track your session\n- **Clear screen** (option 8) to refresh the display\n\n---\n\n## üêõ Troubleshooting\n\n### Build Fails\n```bash\nmake clean\nmake\n```\n\n### Terminal Won't Start\n```bash\nmake terminal\nchmod +x start_trading.sh\n./start_trading.sh\n```\n\n### Orders Not Matching\n- Check that prices cross the spread\n- Buy price must be >= best ask\n- Sell price must be <= best bid\n- View book (option 6) to see current prices\n\n---\n\n## üîí Code Quality Verification\n\n### Compile with Strict Warnings\n```bash\ng++ -std=c++17 -Wall -Wextra -Wpedantic -Werror TradingTerminal.cpp OrderBook.cpp -o trading_terminal\n```\nResult: Zero warnings, zero errors ‚úÖ\n\n### Run Verification Suite\n```bash\n./verify.sh\n```\nAll checks pass ‚úÖ\n\n---\n\n## üìà Performance Benchmarks\n\nTypical performance on modern CPU:\n\n**Order Operations:**\n- Add order (no match): ~50-100 ns\n- Add order (with match): ~100-500 ns\n- Cancel order: ~30-80 ns\n\n**Throughput:**\n- 10M order additions/sec (no match)\n- 2-5M order additions/sec (with match)\n- 15M cancellations/sec\n\n**Memory:**\n- 104 bytes per active order\n- Linear scaling with order count\n- No memory leaks\n\n---\n\n## üé® What Makes This Different\n\n### Professional Quality\n- Production-ready code structure\n- Comprehensive error handling\n- Real-time reporting with precise timestamps\n- Professional branding and UI\n\n### Educational Value\n- Well-documented architecture\n- Clear separation of concerns\n- Modern C++ best practices\n- Realistic implementation patterns\n\n### Practical Design\n- No over-engineering\n- Standard library only\n- Efficient data structures\n- Clean, readable code\n\n---\n\n## ü§ù Contributing\n\nThis is an educational project demonstrating order book implementation. Feel free to:\n- Study the code\n- Extend functionality\n- Use in your projects\n- Share and learn\n\n---\n\n## üìÑ License\n\nEducational and demonstration purposes. Free to use, modify, and learn from.\n\n---\n\n## üéâ Summary\n\nYou have a complete, professional-grade trading system featuring:\n\n‚úÖ High-performance matching engine  \n‚úÖ Interactive trading terminal  \n‚úÖ Real-time execution reporting  \n‚úÖ Comprehensive test suite  \n‚úÖ Complete documentation  \n‚úÖ Zero external dependencies  \n‚úÖ Production-ready code quality  \n\n**Start trading now:**\n```bash\n./start_trading.sh\n```\n\n---\n\n*Quantum Trading Systems - Order Book Engine v2.1*  \n*Built with C++17 - Professional Grade Implementation*  \n*October 2025*\n",
      "technologies": [
        "C++"
      ],
      "githubUrl": "https://github.com/Jaiminp007/High-Performance-Limit-Order-Book",
      "liveUrl": "",
      "featured": false,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "BudgeBuddy_ReactNative_",
      "description": "Personal Budget Managing App",
      "longDescription": "Personal Budget Managing App",
      "readme": "# BudgeBuddy\n\n![BudgetBuddy Logo](assets/Logo.png)\n\n**BudgeBuddy** is a cross-platform personal finance management app built with React Native and Expo. It helps users track cash, manage expenses, visualize spending trends, and provide feedback‚Äîall with a clean, modern UI.\n\n---\n\n## üöÄ Features\n\n- **User Accounts:** Sign up, switch, and delete multiple user accounts.\n- **Cash Management:** Set and update your cash balance.\n- **Expense Tracking:** Add expenses with notes and dates.\n- **Top Expenses:** See your highest expenses at a glance.\n- **Currency Support:** Choose between Rupee, Dollar, Euro, and Pound.\n- **Visual Analytics:** Interactive line chart of your cash history.\n- **Persistent Storage:** All data is stored locally using AsyncStorage.\n- **Feedback Form:** Submit feedback directly from the app.\n- **Navigation Drawer:** Quick access to Dashboard, Feedback, Logout, and Delete Account.\n- **Responsive UI:** Works on Android, iOS, and Web.\n\n---\n\n## üì¶ Project Structure\n\n```\n.\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ components/         # UI components (Login, Main, Expense, Feedback, etc.)\n‚îÇ   ‚îú‚îÄ‚îÄ services/           # API and data service logic\n‚îÇ   ‚îú‚îÄ‚îÄ GlobalData.js       # Global state for user session\n‚îÇ   ‚îú‚îÄ‚îÄ _layout.jsx         # Drawer navigation and layout\n‚îÇ   ‚îú‚îÄ‚îÄ index.jsx           # Entry point\n‚îÇ   ‚îú‚îÄ‚îÄ MainPage.jsx        # Main dashboard page\n‚îÇ   ‚îú‚îÄ‚îÄ LoginPage.jsx       # Landing page after login\n‚îÇ   ‚îú‚îÄ‚îÄ LandingPage.jsx     # Initial cash/currency setup\n‚îÇ   ‚îú‚îÄ‚îÄ ExpensePage.jsx     # Add expense page\n‚îÇ   ‚îî‚îÄ‚îÄ feedback.jsx        # Feedback form page\n‚îú‚îÄ‚îÄ assets/                 # App icons, images, and Lottie animations\n‚îú‚îÄ‚îÄ package.json            # Project dependencies and scripts\n‚îú‚îÄ‚îÄ tsconfig.json           # TypeScript configuration\n‚îú‚îÄ‚îÄ babel.config.js         # Babel configuration\n‚îî‚îÄ‚îÄ app.json                # Expo configuration\n```\n\n---\n\n## üõ†Ô∏è Getting Started\n\n### Prerequisites\n\n- [Node.js](https://nodejs.org/)\n- [Expo CLI](https://docs.expo.dev/get-started/installation/)\n- [Yarn](https://yarnpkg.com/) or [npm](https://www.npmjs.com/)\n\n### Installation\n\n```sh\ngit clone https://github.com/yourusername/BudgeBuddy_ReactNative_.git\ncd BudgeBuddy_ReactNative_\nnpm install\n# or\nyarn install\n```\n\n### Running the App\n\n```sh\nnpm start\n# or\nyarn start\n```\n\n- Press `a` for Android, `i` for iOS, or `w` for Web in the Expo CLI.\n\n---\n\n## üß© Main Technologies\n\n- **React Native** (with Expo)\n- **TypeScript**\n- **React Navigation** (Drawer)\n- **AsyncStorage** (local storage)\n- **react-native-chart-kit** (charts)\n- **Lottie** (animations)\n- **react-native-paper** (UI components)\n\n---\n\n## üìö Key Files\n\n- `app/components/MainScreen.jsx`: Main dashboard UI.\n- `app/components/ExpenseScreen.jsx`: Add and manage expenses.\n- `app/components/LoginScreen.tsx`: User sign up and account selection.\n- `app/components/FeedbackForm.tsx`: Feedback submission form.\n- `app/services/apiHost.js`: API and data logic (for future backend integration).\n- `app/_layout.jsx`: Drawer navigation and layout.\n\n---\n\n## üìù Feedback\n\nWe value your feedback! Use the in-app Feedback form or [open an issue](https://github.com/Jaiminp007/BudgeBuddy_ReactNative_/issues).\n\n---\n\n## üè∑Ô∏è Tags\n\n`react-native` `expo` `personal-finance` `expense-tracker` `mobile-app` `typescript` `asyncstorage` `charts` `lottie` `feedback` `drawer-navigation`\n\n---\n\n## üìÑ License\n\nMIT License. See [LICENSE](LICENSE) for details.\n\n---\n\n## üë§ Author\n\n- [Jaimin](https://github.com/Jaiminp007)\n\n---\n\n> _Happy budgeting with BudgetBuddy!_\n",
      "technologies": [
        "JavaScript"
      ],
      "githubUrl": "https://github.com/Jaiminp007/BudgeBuddy_ReactNative_",
      "liveUrl": "https://www.amazon.com/dp/B0DJ32NFX5/ref=apps_sf_sta",
      "featured": true,
      "image": "/projects/placeholder.png"
    },
    {
      "name": "BudgeBuddy_Python_",
      "description": "Budgebuddy is an app where you can manage your personal finances within the app. It manages your expenses.",
      "longDescription": "Budgebuddy is an app where you can manage your personal finances within the app. It manages your expenses.",
      "readme": "BudgeBuddy\n\nBudgeBuddy is a simple and intuitive expense tracking application developed using Python. It helps you to record, track, and manage your expenses efficiently.\n\nFeatures\n\n- Expense Tracking: Easily record your daily expenses.\n- Categorization: Categorize your expenses for better insights.\n- Analytics: View expense analytics and summaries to understand your spending habits\n- User-friendly Interface: Simple and easy-to-use interface.\n\nRequirements\n\n- Python 3.12\n- The following Python libraries:\n  - matplotlib\n  - tkinter\n\n\n\nTO VIEW THIS APP:\nDOWNLOAD ALL THE PYTHON SCRIPTS IN A SINGLE FOLDER AND RUN THE FILE Login.py.\n",
      "technologies": [
        "Python"
      ],
      "githubUrl": "https://github.com/Jaiminp007/BudgeBuddy_Python_",
      "liveUrl": "https://budge-buddy.vercel.app",
      "featured": true,
      "image": "/projects/placeholder.png"
    }
  ]
};
